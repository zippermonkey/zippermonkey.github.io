<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一篇新文章</title>
      <link href="/20240116/%E4%B8%80%E7%AF%87%E6%96%B0%E6%96%87%E7%AB%A0/"/>
      <url>/20240116/%E4%B8%80%E7%AF%87%E6%96%B0%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><p>hhhh</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Fedora开箱配置</title>
      <link href="/20220412/Fedora%E5%BC%80%E7%AE%B1%E9%85%8D%E7%BD%AE/"/>
      <url>/20220412/Fedora%E5%BC%80%E7%AE%B1%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Gnome插件篇"><a href="#Gnome插件篇" class="headerlink" title="Gnome插件篇"></a>Gnome插件篇</h2><p>使用的插件截图：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/04/12/vnPwD3msrVl1OCp.png" alt="Gnome 插件"></p><h2 id="主题篇"><a href="#主题篇" class="headerlink" title="主题篇"></a>主题篇</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/04/12/JY4zfEPdBuX7WQR.png" alt="GTK theme"></p><ul><li>theme: <a href="https://github.com/vinceliuice/Fluent-gtk-theme">Fluent-gtk-theme</a></li><li>icons: <a href="https://github.com/vinceliuice/Fluent-icon-theme">Fluent-icon-theme</a></li></ul><h2 id="输入法配置"><a href="#输入法配置" class="headerlink" title="输入法配置"></a>输入法配置</h2><p>使用ibus-rime，导入该<a href="https://github.com/zippermonkey/rime-settings">配置文件</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zippermonkey/rime-settings.git</span><br><span class="line"><span class="built_in">rm</span> -rf ~/.config/ibus/rime</span><br><span class="line"><span class="built_in">cp</span> -r rime-settings ~/.config/ibus/rime</span><br></pre></td></tr></table></figure><p>然后配合<a href="https://extensions.gnome.org/extension/2820/ibus-tweaker/">iBus Tweaker</a>插件实现横排和大字体</p><p>输入效果：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/04/12/KOndA3jG8i4MurH.png"></p><h2 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h2><p>设置快捷键<code>Ctrl+Alt+T</code> 为<code>gnome-terminal</code>打开终端</p><h2 id="字体配置"><a href="#字体配置" class="headerlink" title="字体配置"></a>字体配置</h2><p>直接复制<code>Windows</code>的字体过来即可</p><h2 id="flakhub仓库添加"><a href="#flakhub仓库添加" class="headerlink" title="flakhub仓库添加"></a><code>flakhub</code>仓库添加</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo</span><br></pre></td></tr></table></figure><h2 id="必备的软件"><a href="#必备的软件" class="headerlink" title="必备的软件"></a>必备的软件</h2><h3 id="Appimagelauncher"><a href="#Appimagelauncher" class="headerlink" title="Appimagelauncher"></a>Appimagelauncher</h3><blockquote><p>Helper application for Linux distributions serving as a kind of “entry point” for running and integrating AppImages</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/TheAssassin/AppImageLauncher/releases/download/v2.2.0/appimagelauncher-2.2.0-travis995.0f91801.x86_64.rpm</span><br><span class="line">sudo dnf <span class="keyword">in</span> appimagelauncher-2.2.0-travis995.0f91801.x86_64.rpm</span><br></pre></td></tr></table></figure><h3 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf <span class="keyword">in</span> cmake make gcc gcc-c++ git</span><br></pre></td></tr></table></figure><h3 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc</span><br><span class="line">sudo sh -c <span class="string">&#x27;echo -e &quot;[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc&quot; &gt; /etc/yum.repos.d/vscode.repo&#x27;</span></span><br><span class="line">dnf check-update</span><br><span class="line">sudo dnf install code</span><br></pre></td></tr></table></figure><h3 id="texlive"><a href="#texlive" class="headerlink" title="texlive"></a>texlive</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf <span class="keyword">in</span> texlive-scheme-full</span><br></pre></td></tr></table></figure><h3 id="python-virtualenvwrapper"><a href="#python-virtualenvwrapper" class="headerlink" title="python virtualenvwrapper"></a>python virtualenvwrapper</h3><blockquote><p><code>Fedora</code>自带的<code>Python</code>比较新，我平常使用的版本为<code>python3.8</code>，所以我使用<code>virtualenvwrapper</code>管理虚拟环境</p></blockquote><ol><li>安装<code>python3.8</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf <span class="keyword">in</span> python3.8 </span><br></pre></td></tr></table></figure></li><li>安装<code>virtualenvwrapper</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf <span class="keyword">in</span> python3-pip</span><br><span class="line">pip install virtualenvwrapper</span><br></pre></td></tr></table></figure></li><li>设置<code>virtualenvwrapper</code><br>将以下加入到<code>.bashrc</code>(或者其他shell的配置文件)中<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.local/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure></li></ol><h3 id="Zotero"><a href="#Zotero" class="headerlink" title="Zotero"></a>Zotero</h3><blockquote><p>Zotero 是一款自由及开放源代码的文献管理软件，管理书目信息及相关材料。</p></blockquote><p>下载地址：<a href="https://www.zotero.org/download/">https://www.zotero.org/download/</a></p><p>解压之后设置<code>desktop</code>文件的符号链接即可</p><h3 id="坚果云"><a href="#坚果云" class="headerlink" title="坚果云"></a>坚果云</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install glib2-devel gtk2-devel nautilus-devel gvfs libappindicator-gtk3  python3-gobject</span><br><span class="line">wget https://www.jianguoyun.com/static/exe/installer/nutstore_linux_src_installer.tar.gz</span><br><span class="line">tar zxf nutstore_linux_src_installer.tar.gz </span><br><span class="line"><span class="built_in">cd</span> nutstore_linux_src_installer &amp;&amp; ./configure &amp;&amp; make</span><br><span class="line">sudo make install</span><br><span class="line">nautilus -q</span><br><span class="line">./runtime_bootstrap</span><br></pre></td></tr></table></figure><h3 id="音乐软件"><a href="#音乐软件" class="headerlink" title="音乐软件"></a>音乐软件</h3><ul><li><p>listen1</p><p>  项目主页：<a href="https://listen1.github.io/listen1/">listen1</a></p><p>  Appimage下载地址: <a href="https://github.com/listen1/listen1_desktop/releases/download/v2.22.1/listen1_2.22.1_linux_x86_64.AppImage">点击下载</a></p></li><li><p>netease-cloud-music-gtk (<code>rust</code>写的网抑云)</p><p>  项目主页：<a href="https://github.com/gmg137/netease-cloud-music-gtk">netease-cloud-music-gtk</a></p><p>  rpm下载地址: <a href="https://gitee.com/gmg137/netease-cloud-music-gtk/attach_files/689011/download/netease-cloud-music-gtk-1.2.2-1.x86_64.rpm">点击下载</a></p></li></ul><h3 id="WPS"><a href="#WPS" class="headerlink" title="WPS"></a>WPS</h3><p>官网地址：<a href="https://linux.wps.cn/">https://linux.wps.cn/</a></p><ul><li>网页下载安装</li></ul><p>下载64位rpm格式 <code>For X64</code><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/04/12/p9vCxDuB5YQqS8R.png"></p><ul><li>命令行下载安装</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://wps-linux-personal.wpscdn.cn/wps/download/ep/Linux2019/10920/wps-office-11.1.0.10920-1.x86_64.rpm</span><br><span class="line">sudo dnf <span class="keyword">in</span> ./wps-office-11.1.0.10920-1.x86_64.rpm</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker/podman 的使用</title>
      <link href="/20220311/use-docker-podman/"/>
      <url>/20220311/use-docker-podman/</url>
      
        <content type="html"><![CDATA[<p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p><h2 id="image文件"><a href="#image文件" class="headerlink" title="image文件"></a>image文件</h2><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机的所有 image 文件。</span></span><br><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 image 文件</span></span><br><span class="line">$ docker image <span class="built_in">rm</span> [imageName]</span><br></pre></td></tr></table></figure><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><h2 id="docker-hello-world"><a href="#docker-hello-world" class="headerlink" title="docker hello-world"></a>docker hello-world</h2><p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull library/hello-world</span><br></pre></td></tr></table></figure><p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p><p>现在，运行这个 image 文件。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run hello-world</span><br></pre></td></tr></table></figure><p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  ~ podman run hello-world</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -it ubuntu bash</span><br></pre></td></tr></table></figure></p><p>对于那些不会自动终止的容器，必须使用<a href="https://docs.docker.com/engine/reference/commandline/container_kill/"><code>docker container kill</code></a> 命令手动终止。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">kill</span> [containID]</span><br></pre></td></tr></table></figure><h2 id="容器文件"><a href="#容器文件" class="headerlink" title="容器文件"></a>容器文件</h2><p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong>也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机正在运行的容器</span></span><br><span class="line">$ docker container <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本机所有容器，包括终止运行的容器</span></span><br><span class="line">$ docker container <span class="built_in">ls</span> --all</span><br></pre></td></tr></table></figure><p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p><p>终止运行的容器文件，依然会占据硬盘空间，可以使用<a href="https://docs.docker.com/engine/reference/commandline/container_rm/"><code>docker container rm</code></a>命令删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">rm</span> [containerID]</span><br></pre></td></tr></table></figure><p>运行上面的命令之后，再使用<code>docker container ls --all</code>命令，就会发现被删除的容器文件已经消失了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  ~ podman container <span class="built_in">ls</span> --all</span><br><span class="line">CONTAINER ID  IMAGE                                 COMMAND     CREATED        STATUS                    PORTS                     NAMES</span><br><span class="line">c87c02ca1bc2  docker.io/library/mongo:latest        mongod      6 days ago     Exited (0) 17 hours ago   0.0.0.0:27017-&gt;27017/tcp  mongo</span><br><span class="line">27785afa6981  docker.io/library/hello-world:latest  /hello      2 minutes ago  Exited (0) 2 minutes ago                            gallant_chaplygin</span><br><span class="line">(base) ➜  ~ podman container <span class="built_in">rm</span> 2778 </span><br><span class="line">27785afa698114c6551eb1b599595ddb81c2f51c133636c6c86e2168cc9c5472</span><br><span class="line">(base) ➜  ~ podman container <span class="built_in">ls</span> --all</span><br><span class="line">CONTAINER ID  IMAGE                           COMMAND     CREATED     STATUS                   PORTS                     NAMES</span><br><span class="line">c87c02ca1bc2  docker.io/library/mongo:latest  mongod      6 days ago  Exited (0) 17 hours ago  0.0.0.0:27017-&gt;27017/tcp  mongo</span><br></pre></td></tr></table></figure><h2 id="Dockerfile文件"><a href="#Dockerfile文件" class="headerlink" title="Dockerfile文件"></a>Dockerfile文件</h2><p>学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。</p><p>这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p><p>下面通过一个实例，演示如何编写 Dockerfile 文件。</p><h2 id="制作自己的Docker容器"><a href="#制作自己的Docker容器" class="headerlink" title="制作自己的Docker容器"></a>制作自己的Docker容器</h2><p>下面我以 <a href="https://www.ruanyifeng.com/blog/2017/08/koa.html">koa-demos</a> 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。</p><p>作为准备工作，请先<a href="https://github.com/ruanyf/koa-demos/archive/master.zip">下载源码</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/ruanyf/koa-demos.git</span><br><span class="line">$ <span class="built_in">cd</span> koa-demos</span><br></pre></td></tr></table></figure><h3 id="编写dockerfile文件"><a href="#编写dockerfile文件" class="headerlink" title="编写dockerfile文件"></a>编写dockerfile文件</h3><p>首先，在项目的根目录下，新建一个文本文件<code>.dockerignore</code>，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/.dockerignore">内容</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure><p>上面代码表示，这三个&#x3D;&#x3D;路径要排除&#x3D;&#x3D;，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。<br>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/Dockerfile">内容</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br></pre></td></tr></table></figure><p>上面代码一共五行，含义如下。</p><ul><li><code>FROM node:8.4</code>：该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</li><li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li><li><code>WORKDIR /app</code>：指定接下来的工作路径为<code>/app</code>。</li><li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install</code>命令安装依赖。注意，安装后所有的依赖，都将<strong>打包进入 image 文件</strong>。</li><li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li></ul><h2 id="创建image文件"><a href="#创建image文件" class="headerlink" title="创建image文件"></a>创建image文件</h2><p>有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t koa-demo .</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker image build -t koa-demo:0.0.1 .</span><br></pre></td></tr></table></figure><p>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latest</code>。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</p><p>如果运行成功，就可以看到新生成的 image 文件<code>koa-demo</code>了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  koa-demos git:(master) ✗ podman image <span class="built_in">ls</span>                 </span><br><span class="line">REPOSITORY                     TAG         IMAGE ID      CREATED         SIZE</span><br><span class="line">localhost/koa-demo             latest      f36e9ec29443  14 seconds ago  699 MB</span><br><span class="line">docker.io/library/mongo        latest      fefd78e9381a  5 weeks ago     704 MB</span><br><span class="line">docker.io/library/hello-world  latest      feb5d9fea6a5  8 weeks ago     19.9 kB</span><br><span class="line">docker.io/library/node         8.4         386940f92d24  4 years ago     695 MB</span><br></pre></td></tr></table></figure><h3 id="生成容器"><a href="#生成容器" class="headerlink" title="生成容器"></a>生成容器</h3><p><code>docker container run</code>命令会从 image 文件生成容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -p 8000:3000 -it koa-demo /bin/bash</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure><ul><li><code>-p</code>参数：容器的 3000 端口映射到本机的 8000 端口。</li><li><code>-it</code>参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li><li><code>koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li><li><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li></ul><p>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app<span class="comment"># node demos/01.js</span></span><br></pre></td></tr></table></figure><p>这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 <a href="http://127.0.0.1:8000，网页显示&quot;Not">http://127.0.0.1:8000，网页显示&quot;Not</a> Found”，这是因为这个 <a href="https://github.com/ruanyf/koa-demos/blob/master/demos/01.js">demo</a> 没有写路由。</p><p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。</p><p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用<code>docker container kill</code>终止容器运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在本机的另一个终端窗口，查出容器的 ID</span></span><br><span class="line">$ docker container <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止指定的容器运行</span></span><br><span class="line">$ docker container <span class="built_in">kill</span> [containerID]</span><br></pre></td></tr></table></figure><p>容器停止运行之后，并不会消失，用下面的命令删除容器文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查出容器的 ID</span></span><br><span class="line">$ docker container <span class="built_in">ls</span> --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的容器文件</span></span><br><span class="line">$ docker container <span class="built_in">rm</span> [containerID]</span><br></pre></td></tr></table></figure><p>也可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --<span class="built_in">rm</span> -p 8000:3000 -it koa-demo /bin/bash</span><br></pre></td></tr></table></figure><h3 id="CMD命令"><a href="#CMD命令" class="headerlink" title="CMD命令"></a>CMD命令</h3><p>上一节的例子里面，容器启动以后，需要手动输入命令<code>node demos/01.js</code>。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br><span class="line">CMD node demos/01.js</span><br></pre></td></tr></table></figure><p>上面的 Dockerfile 里面，多了最后一行<code>CMD node demos/01.js</code>，它表示容器启动后自动执行<code>node demos/01.js</code>。</p><p>你可能会问，<code>RUN</code>命令与<code>CMD</code>命令的区别在哪里？简单说，<code>RUN</code>命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；<code>CMD</code>命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令。</p><p>注意，指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令。现在，启动容器可以使用下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --<span class="built_in">rm</span> -p 8000:3000 -it koa-demo:0.0.1</span><br></pre></td></tr></table></figure><h3 id="发布image文件"><a href="#发布image文件" class="headerlink" title="发布image文件"></a>发布image文件</h3><p>容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。</p><p>首先，去 <a href="https://hub.docker.com/">hub.docker.com</a> 或 <a href="https://cloud.docker.com/">cloud.docker.com</a> 注册一个账户。然后，用下面的命令登录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure><p>接着，为本地的 image 标注用户名和版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image tag [imageName] [username]/[repository]:[tag]</span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">$ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1</span><br></pre></td></tr></table></figure><p>也可以不标注用户名，重新构建一下 image 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t [username]/[repository]:[tag] .</span><br></pre></td></tr></table></figure><p>最后，发布 image 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image push [username]/[repository]:[tag]</span><br></pre></td></tr></table></figure><p>发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。</p><h2 id="其他有用的命令"><a href="#其他有用的命令" class="headerlink" title="其他有用的命令"></a>其他有用的命令</h2><ol><li><strong>docker container run</strong><br>前面的<code>docker container run</code>命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用<code>docker container start</code>命令，它用来启动已经生成、已经停止运行的容器文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container start [containerID]</span><br></pre></td></tr></table></figure></li><li><strong>docker container stop</strong><br>前面的<code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>docker container stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop [containerID]</span><br></pre></td></tr></table></figure></li><li><strong>docker container logs</strong><br><code>docker container logs</code>命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令查看输出。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container logs [containerID]</span><br></pre></td></tr></table></figure></li><li><strong>docker container exec</strong><br><code>docker container exec</code>命令用于进入一个正在运行的 docker 容器。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">exec</span> -it [containerID] /bin/bash</span><br></pre></td></tr></table></figure></li><li><strong>docker container cp</strong><br><code>docker container cp</code>命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">cp</span> [containID]:[/path/to/file] .</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 容器 </tag>
            
            <tag> docker </tag>
            
            <tag> podman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用vscode写Python</title>
      <link href="/20220122/%E4%BD%BF%E7%94%A8vscode%E5%86%99Python/"/>
      <url>/20220122/%E4%BD%BF%E7%94%A8vscode%E5%86%99Python/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h2><blockquote><p><code>Python</code>官网: <a href="https://www.python.org/">https://www.python.org/</a></p></blockquote><p>下面给出一些常用版本的下载链接，点击下载地址列的版本号即可下载，提供了<strong>镜像下载地址</strong>和<strong>官方下载地址</strong>，为保证下载速度建议使用<strong>镜像下载地址</strong>。</p><p><strong>如果你使用的是Windows 7版本，那么是不能使用3.9及以上的版本的，建议下载3.7或者3.8；此外32bit和64bit的选择与你的操作系统对应（不出意外，现在应该都是64bit吧）</strong></p><table><thead><tr><th>版本</th><th>镜像下载地址</th><th>官方下载地址</th></tr></thead><tbody><tr><td>3.7 (32bit) (Win7 32位用户可用)</td><td><a href="https://registry.npmmirror.com/-/binary/python/3.7.9/python-3.7.9.exe">python-3.7.9.exe</a></td><td><a href="https://www.python.org/ftp/python/3.7.9/python-3.7.9.exe">python-3.7.9.exe</a></td></tr><tr><td>3.7 (64bit) (Win7 64位用户可用)</td><td><a href="https://registry.npmmirror.com/-/binary/python/3.7.9/python-3.7.9-amd64.exe">python-3.7.9-amd64.exe</a></td><td><a href="https://www.python.org/ftp/python/3.7.9/python-3.7.9-amd64.exe">python-3.7.9-amd64.exe</a></td></tr><tr><td>3.8 (32bit)  (Win7 32位用户可用)</td><td><a href="https://registry.npmmirror.com/-/binary/python/3.8.10/python-3.8.10.exe">python-3.8.10.exe</a></td><td><a href="https://www.python.org/ftp/python/3.8.10/python-3.8.10.exe">python-3.8.10.exe</a></td></tr><tr><td>3.8 (64bit) (Win7 64位用户可用)</td><td><a href="https://registry.npmmirror.com/-/binary/python/3.8.10/python-3.8.10-amd64.exe">python-3.8.10-amd64.exe</a></td><td><a href="https://www.python.org/ftp/python/3.8.10/python-3.8.10-amd64.exe">python-3.8.10-amd64.exe</a></td></tr><tr><td>3.9 (32bit)</td><td><a href="https://registry.npmmirror.com/-/binary/python/3.9.10/python-3.9.10.exe">python-3.9.10.exe</a></td><td><a href="https://www.python.org/ftp/python/3.9.10/python-3.9.10.exe">python-3.9.10.exe</a></td></tr><tr><td>3.9 (64bit)</td><td><a href="https://registry.npmmirror.com/-/binary/python/3.9.10/python-3.9.10-amd64.exe">python-3.9.10-amd64.exe</a></td><td><a href="https://www.python.org/ftp/python/3.9.10/python-3.9.10-amd64.exe">python-3.9.10-amd64.exe</a></td></tr><tr><td>3.10 (32bit)</td><td><a href="https://registry.npmmirror.com/-/binary/python/3.10.5/python-3.10.5.exe">python-3.10.5.exe</a></td><td><a href="https://www.python.org/ftp/python/3.10.5/python-3.10.5.exe">python-3.10.5.exe</a></td></tr><tr><td>3.10 (64bit)</td><td><a href="https://registry.npmmirror.com/-/binary/python/3.10.5/python-3.10.5-amd64.exe">python-3.10.5-amd64.exe</a></td><td><a href="https://www.python.org/ftp/python/3.10.5/python-3.10.5-amd64.exe">python-3.10.5-amd64.exe</a></td></tr></tbody></table><p>这里我以<code>Python 3.10</code>，也就是最新版为例，下载完成后双击打开安装包，<br>先勾选下方的<code>Add Python 3.10 to PATH</code>将python安装路径加入到环境变量中，然后点击<code>Install Now</code>，其他东西不用修改保持默认就好</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/01/23/zP6tUFWX2CGL4Hs.png"></p><p>安装完成后，点击<code>close</code>关闭安装程序，此时已经能够在开始菜单中看到新加的程序</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/01/23/q2FMQVmWBXogIOJ.png"></p><p>至此，<code>python</code>的安装就完成了</p><h2 id="安装vscode"><a href="#安装vscode" class="headerlink" title="安装vscode"></a>安装vscode</h2><blockquote><p>Visual Studio Code is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, macOS and Linux. It comes with built-in support for JavaScript, TypeScript and Node.js and has a rich ecosystem of extensions for other languages (such as C++, C#, Java, Python, PHP, Go) and runtimes (such as .NET and Unity). Begin your journey with VS Code with these introductory videos.</p></blockquote><blockquote><p><code>vscode</code>官网: <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p></blockquote><p><code>vscode</code>下载地址: <a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a>，选择自己对应的系统版本下载，这里我选择<code>Windows</code>下载</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/01/23/nQdKhy5SHPu39Dx.png"></p><p>下载完成后，双击安装，保持其默认设置即可，或者在勾选如下图也可以</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/01/23/ti3gfNHzybRxOah.png"></p><p>最后点击完成，完成安装。</p><p>以下是<code>vscode</code>中常用的几个板块，安装插件点击插件图标，然后搜索对应的插件名字点击安装即可</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/01/23/B9A6fb3lGNELtaJ.png"></p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><h3 id="汉化插件Chinese-Simplified-简体中文-Language-Pack-for-Visual-Studio-Code"><a href="#汉化插件Chinese-Simplified-简体中文-Language-Pack-for-Visual-Studio-Code" class="headerlink" title="汉化插件Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code"></a>汉化插件Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code</h3><p>有人可能看不太习惯英文的界面，好在vscode提供了汉化插件，安装之后重启vscode即可完成汉化了</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/01/23/i5JGVdBYr6nAuvL.png"></p><h3 id="python-（必装）"><a href="#python-（必装）" class="headerlink" title="python （必装）"></a>python （必装）</h3><blockquote><p>为<code>vscode</code>添加<code>python</code>语言支持</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/01/22/4PmSOwNbhJk1WXy.png" alt="python插件"></p><h3 id="Error-Lens（可选）"><a href="#Error-Lens（可选）" class="headerlink" title="Error Lens（可选）"></a>Error Lens（可选）</h3><blockquote><p><code>Error Lens</code> 该插件能够将错误信息内联显示在代码中，比较的方便</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/01/22/Wpy15Im7afoEYtj.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/usernamehw/vscode-error-lens/master/img/demo.png"></p><h2 id="创建并打开文件夹"><a href="#创建并打开文件夹" class="headerlink" title="创建并打开文件夹"></a>创建并打开文件夹</h2><blockquote><p>个人理解<code>vscode</code>的工作区类似于<code>Visual Studio</code>的解决方案这一层，而文件夹则对应项目这一层。</p></blockquote><p>首先在电脑新建一文件夹，该文件夹用来存放<code>python</code>代码，也就是对应了一个项目。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/01/22/9bYgNU1OqlAKzhH.png"></p><p>然后从vscode打开文件夹，点击文件-&gt;打开文件夹，也可以使用快捷方式<code>Crtl+K Ctrl+O</code></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/01/22/2GfnoM67g4yPDcH.png"></p><p>选择刚刚创建的文件夹<code>learnPython</code>打开</p><h3 id="编写普通-py文件"><a href="#编写普通-py文件" class="headerlink" title="编写普通.py文件"></a>编写普通<code>.py</code>文件</h3><p>打开文件夹之后，可以新建一个<code>hello.py</code>文件测试一下</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/01/22/hu8aTD1vGLyVQCw.png"></p><p>在新建的文件夹中写一段代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure><p>注意：<code>vscode</code>识别到后缀为<code>.py</code>的文件，激活<code>Python</code>插件，此时窗口<strong>左下角(新版vscode在右下角)<strong>出现当前使用的解释器，点击窗口</strong>右上角</strong>的运行按钮，即可在<code>vscode</code>内部终端看到运行结果</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/01/22/M6Z9J1TzOCkK4wI.png" alt="运行"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/06/30/lSrTBK5Y8gwI1LF.png" alt="新版vscode"><br>至此，已经可以使用<code>vscode</code>运行<code>python</code>代码了，如果你安装了多个解释器，那么点击**左下角(新版vscode在右下角)**的解释器版本即可选择不同的解释器。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello-world</title>
      <link href="/20220121/hello-world/"/>
      <url>/20220121/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Categories-amp-Tags"><a href="#Categories-amp-Tags" class="headerlink" title="Categories &amp; Tags"></a>Categories &amp; Tags</h3><p>Only posts support the use of categories and tags. Categories apply to posts in order, resulting in a hierarchy of classifications and sub-classifications. Tags are all defined on the same hierarchical level so the order in which they appear is not important.</p><p><strong>Example</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> Sports</span><br><span class="line"><span class="bullet">-</span> Baseball</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> Injury</span><br><span class="line"><span class="bullet">-</span> Fight</span><br><span class="line"><span class="bullet">-</span> Shocking</span><br></pre></td></tr></table></figure><p>If you want to apply multiple category hierarchies, use a list of names instead of a single name. If Hexo sees any categories defined this way on a post, it will treat each category for that post as its own independent hierarchy.</p><p><strong>Example</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> [Sports, Baseball]</span><br><span class="line"><span class="bullet">-</span> [MLB, American League, Boston Red Sox]</span><br><span class="line"><span class="bullet">-</span> [MLB, American League, New York Yankees]</span><br><span class="line"><span class="bullet">-</span> Rivalries</span><br></pre></td></tr></table></figure><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="mathjax-test"><a href="#mathjax-test" class="headerlink" title="mathjax test"></a>mathjax test</h3><p>质能方程$E&#x3D;mc^2$</p><p>行间公式<br>$$<br>E &#x3D; mc^2<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
